# 什么是哈希表

哈希表（Hash table，也叫散列表）是根据 Key 直接访问 value 的数据结构。它通过把 key 映射到表中一个位置来访问 value, 以加快查找的速度。

value 的存储位置 = f(key)

这里的 f 称为散列函数,又称为哈希（Hash函数）,采用散列技术将 value 存储在一块连续的内存空间中-----这块连续空间称为散列表或哈希表（Hash table）。

哈希表 hashtable(key,value) 就是把 Key　通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字,然后就将该数字对数组长度进行取余,取余结果当作
数组的下标, 将 value　存储在以该数字为下标的数组空间里。而当使用哈希表进行查询的时候, 就是再次使用哈希函数将 key 转换为对应的数组下标并定位到该空间获取 value. __如此一来, 就可以充分利用到数组的定位性能进行数据定位__。

数组的特点是:寻址容易, 插入和删除困难; 而链表的特点是:寻址困难,插入和删除容易。

那么我们能不能综合两者的特性，做出一种寻址容易, 插入删除也容易的数据结构?

答案是哈希表

# 哈希函数

哈希查找第一步就是使用哈希函数将键映射成索引, 这种映射函数就是哈希函数。

好的哈希函数=计算简单+分布均匀（计算得到的散列地址分布均匀）

# 避免哈希冲突

## 拉链法 (Separate chaining with linked lists)

将大小为 M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。

![Separatechainingwithlinkedlists](https://github.com/xianfeng92/Fuck-Funny-DataStructure-Algorithms/blob/master/images/Separatechainingwithlinkedlists.png)

上图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。
实现基于拉链表的散列表，目标是选择适当的数组大小　M，使得既不会因为空链表而浪费内存空间，也不会因为链表太长而在查找上浪费太多时间。

## 线性探测法

线性探测法的基本原理为：使用大小为M的数组来保存N个键值对，其中 M>N，我们需要使用数组中的空位解决碰撞冲突。如下图所示：

![LinearProbing](https://github.com/xianfeng92/Fuck-Funny-DataStructure-Algorithms/blob/master/images/LinearProbing.png)

在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，
但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现 153 没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，
发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了 154 上。

线性探测法（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。

# 哈希表的应用

1. Hash 主要用于信息安全领域中加密算法, 它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做 Hash 值。也可以说，Hash 就是找到一种
   数据内容和数据存放地址之间的映射关系。

2. 查找：哈希表，又称为散列，是一种更加快捷的查找技术。常见的查找思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，
   继续查找。而哈希表是完全另外一种思路：当我知道 key 值以后，可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！

3. Hash 表在海量数据处理中也有着广泛应用。

# 哈希表的优缺点

## 优点

在计算机程序中, 如果需要在一秒种内查找上千条记录通常使用哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快,编程实现也相对容易。
__如果不需要有序遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度和易用性方面是无与伦比的__。

## 缺点

它是基于数组的, 数组创建后难于扩展. 某些哈希表被基本填满时,性能下降得非常严重, 所以必须要清楚表中将要存储多少数据（或者准备好定期地把数据
转移到更大的哈希表中，这是个费时的过程）。
